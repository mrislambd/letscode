[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Structure and Algorithms",
    "section": "",
    "text": "Leetcode 69: Sqrt(x)\n\nGiven a non-negative integer, \\(x\\), return the square root of \\(x\\) rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou may not use any built-in exponent function. For example, x**0.5 in python.\nExample:\n Input: x=4\n Output: 2  \n\n Input: x=8\n Output: 2\nExplanation: Square root of 4 is 2 and square root of 8 is 2.8284. But we need to round down to any fraction. Therefore, the square root of 8 is also 2.\nSolution:\nThe square root of any number \\(x\\ge 0\\) is less than or equal to \\(x\\). The brute force solution to this would be \\(\\mathcal{O}(\\sqrt{n})\\). Because, say \\(x=8\\), then\nfor \\(i=1\\) to 8: \\[\\begin{align*}\n   1^2 & = 1 &lt;8 \\\\\n   2^2 & = 4 &lt;8\\\\\n   3^2 & = 9 &gt;8\n\\end{align*}\\]\n\nIn contrast, if we explore binary search then the time complexity reduces to \\(\\mathcal{O}(\\log{n})\\). Say the square root is \\(s\\) which is the middle value in the range of 1 to \\(x\\). Then if \\(s^2&gt;x\\), we search for the root in the left half. Otherwise, if \\(s^2&lt;x\\) then we search the right side. However, when \\(s^2&lt;x\\), then \\(s\\) is a possible candidate for the square root.\nAlgorithm:\n\nset left value \\(l= 0\\), right value \\(r= x\\)\n\nCompute the middle value \\(m=l+(r-l)/2\\)\n\nIf \\(m^2 &gt; x\\) then search the left side: set \\(r=m-1\\)\n\nIf \\(m^2 &lt; x\\) then search the right side: set \\(l=m+1\\)\n\n def square_root(x):\n   l, r = 0, x \n   sq = 0\n   while l&lt;=r:\n     m = l + (r-l)//2 \n     if m**2 &gt; x:\n       r= m-1\n     elif m**2 &lt; x:\n       l = m+1 \n       sq = m\n     else:\n       return m  \n   return sq \n\n print(square_root(6))\n2\n\n\n\nitem\n\nitem"
  },
  {
    "objectID": "index.html#binary-search",
    "href": "index.html#binary-search",
    "title": "Data Structure and Algorithms",
    "section": "",
    "text": "Leetcode 69: Sqrt(x)\n\nGiven a non-negative integer, \\(x\\), return the square root of \\(x\\) rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou may not use any built-in exponent function. For example, x**0.5 in python.\nExample:\n Input: x=4\n Output: 2  \n\n Input: x=8\n Output: 2\nExplanation: Square root of 4 is 2 and square root of 8 is 2.8284. But we need to round down to any fraction. Therefore, the square root of 8 is also 2.\nSolution:\nThe square root of any number \\(x\\ge 0\\) is less than or equal to \\(x\\). The brute force solution to this would be \\(\\mathcal{O}(\\sqrt{n})\\). Because, say \\(x=8\\), then\nfor \\(i=1\\) to 8: \\[\\begin{align*}\n   1^2 & = 1 &lt;8 \\\\\n   2^2 & = 4 &lt;8\\\\\n   3^2 & = 9 &gt;8\n\\end{align*}\\]\n\nIn contrast, if we explore binary search then the time complexity reduces to \\(\\mathcal{O}(\\log{n})\\). Say the square root is \\(s\\) which is the middle value in the range of 1 to \\(x\\). Then if \\(s^2&gt;x\\), we search for the root in the left half. Otherwise, if \\(s^2&lt;x\\) then we search the right side. However, when \\(s^2&lt;x\\), then \\(s\\) is a possible candidate for the square root.\nAlgorithm:\n\nset left value \\(l= 0\\), right value \\(r= x\\)\n\nCompute the middle value \\(m=l+(r-l)/2\\)\n\nIf \\(m^2 &gt; x\\) then search the left side: set \\(r=m-1\\)\n\nIf \\(m^2 &lt; x\\) then search the right side: set \\(l=m+1\\)\n\n def square_root(x):\n   l, r = 0, x \n   sq = 0\n   while l&lt;=r:\n     m = l + (r-l)//2 \n     if m**2 &gt; x:\n       r= m-1\n     elif m**2 &lt; x:\n       l = m+1 \n       sq = m\n     else:\n       return m  \n   return sq \n\n print(square_root(6))\n2\n\n\n\nitem\n\nitem"
  }
]